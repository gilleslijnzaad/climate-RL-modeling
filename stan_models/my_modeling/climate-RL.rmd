---
title: "Climate-RL Stan models"
author: "Gilles Lijnzaad"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float:
      collapsed: TRUE
    number_sections: true
    highlight: tango
---

```{r setup, include = FALSE}
knitr::knit_hooks$set(purl = knitr::hook_purl) # creates an R file upon knitting the Rmd
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(fig.width = 10, fig.height = 4)
```

# Loading the data
The data are coming from the R simulation. The `sim_param_settings` file shows what parameters we ran the simulation with (parameters `LR`, `inv_temp`, `initQF`, `initQU`, `mu_R`, `sigma_R`), so we're sure what data we're looking at. The `sim_dat` file shows the simulated data (`T`, `choice`, `R`).

```{r loading-data, message=FALSE}
sim_dir <- "~/research/climate-RL/R_simulation/"
library(rjson)
param_settings <- fromJSON(file = paste0(sim_dir, "sim_param_settings.json"))
data <- fromJSON(file = paste0(sim_dir, "sim_dat.json"))
library(dplyr)
glimpse(param_settings)
glimpse(data)
```

# Defining the model
I show the Stan model code bit by bit to explain what is happening.

## `data` block
The data we supply to the model consist of:

1. the number of participants: `n_part`;
1. the number of trials per participant: `T`;
1. an array of choices that a participant made: `choice[n_part, T]`;
1. an array of ratings that a participant gave: `R[n_part, T]`. These are analogous to the array `outcomes[T]` in the `2arm_bandit_example` (see [Stan code](https://github.com/gilleslijnzaad/climate-RL-modeling/blob/main/stan_models/2arm_bandit_example/2arm_bandit_example.stan) for this example).

```{r defmod-data}
mod <- ""
mod <- paste0(mod, 
"data {
  int<lower=1> n_part;
  int<lower=1> T;
  array[n_part, T] int<lower=1, upper=2> choice;
  array[n_part, T] int<lower=0, upper=10> R;
}
")
```

## `parameters` block
In the current model, we have six free parameters:

1. learning rate 
1. inverse temperature
1. initial Q for friendly
1. initial Q for unfriendly
1. rating mean
1. rating std dev

I copied the `2arm_bandit_example` ([see code](https://github.com/gilleslijnzaad/climate-RL-modeling/blob/main/stan_models/2arm_bandit_example/2arm_bandit_example.stan)) in defining "raw parameters" that we later convert using inverse logit transformation.

When I make the model hierarchical, these parameters will be group-level means and standard deviations.

```{r defmod-params}
mod <- paste0(mod, "
parameters {
  real<lower=0, upper=1> LR_raw;
  real<lower=0, upper=5> inv_temp_raw;
  real<lower=0, upper=10> initQF_raw;
  real<lower=0, upper=10> initQU_raw;
  real<lower=0, upper=10> mu_R_raw;
  real<lower=0, upper=10> sigma_R_raw;
}
")
```

## `transformed parameters` block
This approach copies the `2arm_bandit` approach. 
```{r defmod-transf-params}
mod <- paste0(mod, "
transformed parameters {
  real<lower=0, upper=1> LR;
  real<lower=0, upper=10> inv_temp;
  real<lower=0, upper=10> initQF;
  real<lower=0, upper=10> initQU;
  real<lower=0, upper=10> mu_R;
  real<lower=0, upper=10> sigma_R;

  LR = inv_logit(LR_raw);
  inv_temp = inv_logit(inv_temp_raw) * 10.0;
  initQF = inv_logit(initQF_raw) * 10.0;
  initQU = inv_logit(initQU_raw) * 10.0;
  mu_R = inv_logit(mu_R_raw) * 10.0; 
  sigma_R = inv_logit(sigma_R_raw) * 10.0;
}
")
```

## `model` block
### The priors
Again, following the `2arm_bandit_example` approach.
```{r defmod-model-priors}
mod <- paste0(mod, "
model {
  // priors: all uninformative
  LR_raw ~ normal(0, 1);
  inv_temp_raw ~ normal(0, 1);
  initQF_raw ~ normal(0, 1);   
  initQU_raw ~ normal(0, 1);   
  mu_R_raw ~ normal(0, 1);          
  sigma_R_raw ~ normal(0, 1);
")
```

### Participant loop
For every participant I initialize an array for holding the Q values. I also create a temporary vector `Q_t` that holds the two Q values (F, U) for the *current* trial, because otherwise the `categorical_logit` wouldn't work, somehow. This works for now, and maybe in the future I will find a more elegant solution.
```{r defmod-model-inits}
mod <- paste0(mod, "
  for (j in 1:n_part) {
    array[T, 2] real Q;
    Q[1, 1] = initQF;
    Q[1, 2] = initQU;
    vector[2] Q_t;

    real pred_err;
")
```

### Trial loop
```{r defmod-data-trials}
mod <- paste0(mod, "
    for (t in 1:T) {
      Q_t = to_vector(Q[t]);

      // sample choice (0 is F, 1 is U) via softmax
      choice[j, t] ~ categorical_logit(inv_temp * Q_t);

      // rate
      R[j, t] ~ normal(mu_R, sigma_R);

      // prediction error
      if (choice[j, t] == 0) {
        pred_err = R[j, t] - Q[t, 1];
      } else {
        pred_err = R[j, t] - Q[t, 2];
      }

      // update value (learn)
      if (t < T) {    // no updating in the very last trial
        if (choice[j, t] == 0) {
          Q[t+1, 1] = Q[t, 1] + LR * pred_err;
          Q[t+1, 2] = Q[t, 2];
        } else {
          Q[t+1, 1] = Q[t, 1];
          Q[t+1, 2] = Q[t, 2] + LR * pred_err;
        }
      }
    }
  }
}
")
```

## Save Stan code
```{r save-stan}
mod_dir <- "~/research/climate-RL/stan_models/my_modeling/"
write(mod, file = paste0(mod_dir, "climate-RL.stan"))
```

# Fitting the model
## Run it
```{r run-model}
library(cmdstanr)

# function allows for easily changing whether you want to refit or use a saved fit
fit_model <- function(refit) {
  if (refit) {
    m <- cmdstan_model(paste0(mod_dir, "climate-RL.stan"))
    data_file <- paste0(sim_dir, "sim_dat.json")
    it <- 10000
    fit <- m$sample(
      data = data_file,
      iter_sampling = it,
      chains = 1,
      thin = 1,
      # init = my_inits,
      iter_warmup = it / 2,
      refresh = it / 5,
      seed = 1234
    )
    fit$save_object(file = paste0(mod_dir, "climate-RL_fit.rds"))
  } else {
    fit <- readRDS(file = paste0(mod_dir, "climate-RL_fit.rds"))
  }
  return(fit)
}

fit <- fit_model(FALSE)
```

## Inspect results
```{r inspect-model-1}
LR_post <- fit$draws("LR")
print(paste0("sim: ", param_settings$LR, "      fit: ", mean(LR_post)))
inv_temp_post <- fit$draws("inv_temp")
print(paste0("sim: ", param_settings$inv_temp, "      fit: ", mean(inv_temp_post)))
```

Here I'm not sure why the inverse temperature is off by a factor of 10. Other parameters don't have this issue. Thoughts?

```{r inspect-model-2}
plot_data <- data.frame(
  draws = c(array(fit$draws("initQF")),
            array(fit$draws("initQU")),
            array(fit$draws("mu_R"))),
  parameter = c(rep("initQF", length(fit$draws("initQF"))),
                rep("initQU", length(fit$draws("initQU"))),
                rep("mu_R", length(fit$draws("mu_R"))))
)

library(ggplot2)
my_teal <- "#008080"
my_pink <- "#ff00dd"
my_blue <- "#11ccff"
update_geom_defaults("density", list(linewidth = 1.5))
update_geom_defaults("vline", list(linewidth = 1.5))
my_theme <- theme_bw() +
  theme(plot.title = element_text(size = 20, face = "bold")) +
  theme(axis.text = element_text(size = 16),
        axis.title = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18, face = "bold"),
        legend.text = element_text(size = 16)) +
  theme(strip.text.x = element_text(size = 18, face = "bold"))

ggplot() +
  geom_density(data = plot_data, aes(x = draws, color = parameter, fill = parameter), alpha = 0.6) +
  labs(x = "Estimate", y = "Density") +
  scale_fill_manual(values = c(my_teal, my_pink, my_blue)) +
  scale_color_manual(values = c(my_teal, my_pink, my_blue)) +
  geom_vline(aes(xintercept = param_settings$initQF, linetype = "simulated value"), color = my_teal) +
  geom_vline(aes(xintercept = param_settings$initQU, linetype = "simulated value"), color = my_pink) +
  geom_vline(aes(xintercept = param_settings$mu_R, linetype = "simulated value"), color = my_blue) +
  geom_vline(alpha = 0.6) +
  scale_linetype_manual(values = c("simulated value" = 2), name = NULL) +
  my_theme
```

# Some next steps
1. Implement confirmation bias!
1. Create a `generated quantities` block to see what Q values, choices and ratings the model predicts;
1. Hierarchically estimate parameter values for participants;
1. "Cosmetic" improvement: remove the temporary `Q_t` vector;
1. "Cosmetic" improvement in the trial loop. The code for updating values is a bit unwieldy now, so I would prefer it to look something like this if possible:
```
Q[t+1, choice[t]] = Q[t, choice[t]] + LR * pred_error
Q[t+1, !choice[t]] = Q[t, !choice[t]]
```