---
title: "Stan models"
author: "Gilles Lijnzaad"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float:
      collapsed: TRUE
    number_sections: true
    highlight: tango
    code_folding: hide
---

```{r setup, include = FALSE}
knitr::knit_hooks$set(purl = knitr::hook_purl) # creates an R file upon knitting the Rmd
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(fig.width = 10, fig.height = 4)
```

# The data
## Running the simulation
For the full simulation code, see [sim.R](../../R_simulation/sim_showcase.html#0_Simulation_code).
```{r create-data}
rm(list = ls())
sim_dir <- "../../R_simulation/"
source(paste0(sim_dir, "sim.R"))

params <- list(
  n_part = 30,
  n_trials = 200,
  LR = 0.25,
  inv_temp = 1,
  initQF = 5,
  initQU = 5,
  mu_R = c(8, 2), # F and U
  sigma_R = 2
)

sim_dat <- run_sim(params, save_to_JSON = TRUE)

cat(paste0("PARAMETER SETTINGS:"), capture.output(dplyr::glimpse(params)), sep = "\n")
cat(paste0("SIMULATED DATA:"), capture.output(dplyr::glimpse(sim_dat)), sep = "\n")
```

## Inspecting the data
Just so I know what to expect of our model, I include plots of the Q values and choices over time.

```{r inspecting-data, warning = FALSE}
library(grid)
library(gridExtra)
grid.arrange(plot_Q(sim_dat), plot_choice(sim_dat), nrow = 1,
                        top = textGrob("Simulated data", gp = gpar(fontsize = 20, font = 2)))
my_annotation(params, extra_vertical_spacing = TRUE)
```

# Defining the model
I show the Stan model code bit by bit to explain what is happening.

## `data` block
The data we supply to the model consist of:

1. the number of participants: `n_part`;
1. the number of trials per participant: `n_trials`;
1. an array of choices that a participant made: `choice[n_part, n_trials]`;
1. an array of ratings that a participant gave: `R[n_part, n_trials]`. These are analogous to the array `outcomes[n_trials]` in the `2arm_bandit_example` (see [Stan code](https://github.com/gilleslijnzaad/climate-RL-modeling/blob/main/stan_models/2arm_bandit_example/2arm_bandit_example.stan) for this example).

```{r defmod-data}
mod <- ""
mod <- paste0(mod, 
"data {
  int<lower=1> n_part;
  int<lower=1> n_trials;
  array[n_part, n_trials] int<lower=1, upper=2> choice;
  array[n_part, n_trials] int<lower=0, upper=10> R;
  int<lower=0, upper=10> initQF;
  int<lower=0, upper=10> initQU;
}
")
```

## `parameters` block
In the current model, we have two free parameters:

1. learning rate 
1. inverse temperature

When I make the model hierarchical, these parameters will be group-level means and standard deviations.

```{r defmod-params}
mod <- paste0(mod, "
parameters {
  real<lower=0, upper=1> LR;
  real<lower=0, upper=5> inv_temp;
}
")
```

## `transformed parameters` block
In the future, I will use this block to define the individual parameter values based on the group mean.
```{r defmod-transf-params}
mod <- paste0(mod, "
// transformed parameters {
// }
")
```

## `model` block
### The priors
```{r defmod-model-priors}
mod <- paste0(mod, "
model {
  // this is where priors would go. leaving them empty leads to uninformative priors
")
```

### Participant loop
For every participant I initialize an array for holding the Q values. I also create a temporary vector `Q_t` that holds the two Q values (F, U) for the *current* trial, because otherwise the `categorical_logit` wouldn't work, somehow. This works for now, and maybe in the future I will find a more elegant solution.
```{r defmod-model-inits}
mod <- paste0(mod, "
  for (j in 1:n_part) {
    array[n_trials, 2] real Q;
    Q[1, 1] = initQF;
    Q[1, 2] = initQU;
    vector[2] Q_t;

    real pred_err;
")
```

### Trial loop
```{r defmod-data-trials}
mod <- paste0(mod, "
    for (t in 1:n_trials) {
      Q_t = to_vector(Q[t]);

      // sample choice (1 is F, 2 is U) via softmax
      choice[j, t] ~ categorical_logit(inv_temp * Q_t);

      // prediction error
      pred_err = R[j, t] - Q[t, choice[j, t]];

      // update value (learn)
      if (t < n_trials) {    // no updating in the very last trial
        if (choice[j, t] == 1) {
          Q[t+1, 1] = Q[t, 1] + LR * pred_err;
          Q[t+1, 2] = Q[t, 2];
        } else {
          Q[t+1, 1] = Q[t, 1];
          Q[t+1, 2] = Q[t, 2] + LR * pred_err;
        }
      }
    }
  }
}
")
```

## Save Stan code
```{r save-stan}
write(mod, file = "climate-RL.stan")
```

# Fitting the model
## Run it
```{r run-model, stdout = TRUE}
library(cmdstanr)
options(mc.cores = parallel::detectCores())

# code allows for easily changing whether you want to refit or use a saved fit
it <- 1000
refit = FALSE
if (refit) {
  m <- cmdstan_model("climate-RL.stan")
  data_file <- paste0(sim_dir, "sim_dat.json")
  fit <- m$sample(
    data = data_file,
    iter_sampling = it,
    chains = 1,
    thin = 1,
    iter_warmup = it / 2,
    refresh = it / 5,
    seed = 1234
  )
  fit$save_object(file = "climate-RL_fit.rds")
} else {
  fit <- readRDS(file = "climate-RL_fit.rds")
}
```

## Inspect results
```{r inspect-results}
source("../../plot_utils.R")
posterior_density_plot(fit, c("LR", "inv_temp"), params)
```

# Some next steps
1. Hierarchically estimate parameter values for participants;
1. Implement confirmation bias;
1. Create a `generated quantities` block to see what Q values, choices and ratings the model predicts;
1. "Cosmetic" improvement: remove the temporary `Q_t` vector;