---
title: "Stan models"
author: "Gilles Lijnzaad"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float:
      collapsed: TRUE
    number_sections: true
    highlight: tango
    code_folding: hide
---

```{r setup, include = FALSE}
knitr::knit_hooks$set(purl = knitr::hook_purl) # creates an R file upon knitting the Rmd
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(fig.width = 10, fig.height = 4)
```

# The data
## Running the simulation
For the full simulation code, see [run_sim()](../../R_simulation/sim_showcase.html#0_Simulation_code).
```{r create-data}
rm(list = ls())
main_dir <- "~/research/climate-RL/"
sim_dir <- paste0(main_dir, "R_simulation/")
sim <- new.env()
source(paste0(sim_dir, "sim.R"), local = sim)  # access functions using sim$fun()

params <- list(
  n_part = 20,
  n_trials = 30,
  LR = 0.3,
  inv_temp = 1.2,
  initQF = 3,
  initQU = 7,
  mu_R = c(5, 5), # F and U
  sigma_R = 3
)

sim_dat <- sim$run_sim(params, save_to_JSON = FALSE)

cat(paste0("PARAMETER SETTINGS:"), capture.output(dplyr::glimpse(params)), sep = "\n")
cat(paste0("SIMULATED DATA:"), capture.output(dplyr::glimpse(sim_dat)), sep = "\n")
```

## Inspecting the data
Just so I know what to expect of our model, I include plots of the Q values and choices over time.

```{r inspecting-data, warning = FALSE}
library(grid)
library(gridExtra)

plot <- new.env()
source(paste0(main_dir, "plot_utils.R"), local = plot)  # access functions using plot$fun()

grid.arrange(plot$Q(sim_dat), plot$choice(sim_dat), nrow = 1,
             top = textGrob("Simulated data", gp = gpar(fontsize = 20, font = 2)))
plot$param_annotation(params, extra_vertical_spacing = TRUE) 
```

# Explaining the model
I show the Stan model code bit by bit to explain what is happening. The full code can be found in [climate-RL.stan](climate-RL.stan).

## `data` block
The data we supply to the model consist of:

1. the number of participants: `n_part`;
1. the number of trials per participant: `n_trials`;
1. an array of choices that a participant made: `choice[n_part, n_trials]`;
1. an array of ratings that a participant gave: `R[n_part, n_trials]`. These are analogous to the array `outcomes[n_trials]` in the `2arm_bandit_example` (see [Stan code](https://github.com/gilleslijnzaad/climate-RL-modeling/blob/main/stan_models/2arm_bandit_example/2arm_bandit_example.stan) for this example).

```{r explmod-data, comment = NA}
mod_code <- readLines("climate-RL.stan")
start <- grep("data \\{", mod_code)[1]
end <- grep("transformed data \\{", mod_code) - 2
cat(mod_code[start:end], sep = "\n")
```

## `transformed data` block
Currently unused.
```{r explmod-transf-data, eval = FALSE, comment = NA}
start <- grep("transformed data \\{", mod_code)
end <- grep("parameters \\{", mod_code)[1] - 2
cat(mod_code[start:end], sep = "\n")
```

## `parameters` block
In the current model, we have four free parameters:

1. learning rate;
1. inverse temperature;
1. initial Q value for the climate-friendly option;
1. initial Q value for the climate-unfriendly option.

When I make the model hierarchical, these parameters will be group-level means and standard deviations.

```{r explmod-params, comment = NA}
start <- grep("parameters \\{", mod_code)[1]
end <- grep("transformed parameters \\{", mod_code) - 2
cat(mod_code[start:end], sep = "\n")
```

## `transformed parameters` block
Currently unused. Will be used to define individual parameter values based on the group mean.
```{r explmod-transf-params, eval = FALSE, comment = NA}
start <- grep("transformed parameters \\{", mod_code)
end <- grep("model \\{", mod_code) - 2
cat(mod_code[start:end], sep = "\n")
```

## `model` block
### The priors
```{r explmod-model-priors, comment = NA}
start <- grep("model \\{", mod_code)
end <- grep("participant loop", mod_code)[1] - 2
cat(mod_code[start:end], sep = "\n")
```

### Participant loop
For every participant I initialize an array for holding the Q values. I also create a temporary vector `Q_t` that holds the two Q values (F, U) for the *current* trial, because otherwise the `categorical_logit` wouldn't work, somehow. This works for now, and maybe in the future I will find a more elegant solution.
```{r explmod-model-part, comment = NA}
start <- grep("participant loop", mod_code) + 1
end <- grep("trial loop", mod_code) - 2
cat(mod_code[start:end], sep = "\n")
```

### Trial loop
```{r explmod-model-trial, comment = NA}
start <- grep("trial loop", mod_code) + 1
end <- grep("generated quantities", mod_code) - 2
cat(mod_code[start:end], sep = "\n")
```

## `generated quantities` block
Currently unused. Will be used in the future to generate posterior predictions.
```{r explmod-gen-quant, eval = FALSE, comment = NA}
start <- grep("generated quantities", mod_code)
end <- length(mod_code)
cat(mod_code[start:end], sep = "\n")
```

# Fitting the model
## Run it
To save running time, I only refit the model if the simulated data have changed (i.e., if I changed parameter settings). To this end, I compare the previously saved `sim_data.json` to the current `sim_dat`. After this comparison, I can save the new `sim_data` and refit the model if necessary.

```{r run-model}
data_file <- paste0(sim_dir, "sim_dat.json")
dat_changed <- sim$did_sim_dat_change(data_file, sim_dat)
sim$save_sim_dat(params, sim_dat)
model_changed <- FALSE

library(cmdstanr)
options(mc.cores = parallel::detectCores())
if (dat_changed | model_changed) {
  m <- cmdstan_model("climate-RL.stan")
  it <- 1000
  fit <- m$sample(
    data = data_file,
    iter_sampling = it,
    chains = 1,
    thin = 1,
    iter_warmup = it / 2,
    refresh = it / 5,
    seed = 1234
  )
  fit$save_object(file = "climate-RL_fit.rds")
} else {
  fit <- readRDS(file = "climate-RL_fit.rds")
}
```

## Inspect results
```{r posterior-plots, fig.height = 8}
plot$posterior_density(fit, c("LR", "inv_temp", "initQF", "initQU"), params)
```
```{r posterior-table}
cred_int <- function(posterior_dist) {
  return(as.numeric(quantile(posterior_dist, c(0.025, 0.975))))
}

print_posterior_table <- function(fit, to_show, param_settings) {
  table_data <- data.frame()

  for (param in to_show) {
    sim_value <- param_settings[[param]]
    dat <- data.frame(
      parameter = param,
      sim_value = sim_value,
      median_CI = sprintf("%.2f [%.2f, %.2f]",
                          median(fit$draws(param)),
                          cred_int(fit$draws(param))[1],
                          cred_int(fit$draws(param))[2])
    )
    table_data <- rbind(table_data, dat)
  }
  colnames <- c("Parameter", "Simulated value",
                "Median [95% credibility interval]")
  knitr::kable(table_data,
               col.names = colnames,
               align = "lll",
               caption = "Posteriors for all free parameters") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left")
}

print_posterior_table(fit, c("LR", "inv_temp", "initQF", "initQU"), params)
```

# Some next steps
1. Hierarchically estimate parameter values for participants;
1. Implement confirmation bias;
1. Create a `generated quantities` block to see what Q values, choices and ratings the model predicts;
1. "Cosmetic" improvement: remove the temporary `Q_t` vector;